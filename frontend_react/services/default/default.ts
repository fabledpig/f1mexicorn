/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * F1 Mexicorn
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import axios from 'axios';
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';

import type {
  GetRacesF1SessionsGetParams,
  GetWinnersResultsWinnersGet200,
  GetWinnersResultsWinnersGetParams,
  GoogleAuthorizationToken,
  Guess,
  HTTPValidationError,
  Race,
  RaceDriver,
  SessionDriversF1SessionDriversGetParams,
  SessionStandingF1SessionStandingPostParams,
  Standings,
  UserInfo,
} from '.././model';

/**
 * @summary Google Auth
 */
export const googleAuthUsersAuthGooglePost = (
  googleAuthorizationToken: GoogleAuthorizationToken,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<UserInfo>> => {
  return axios.post(`/users/auth/google`, googleAuthorizationToken, options);
};

export const getGoogleAuthUsersAuthGooglePostMutationOptions = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof googleAuthUsersAuthGooglePost>>,
    TError,
    { data: GoogleAuthorizationToken },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof googleAuthUsersAuthGooglePost>>,
  TError,
  { data: GoogleAuthorizationToken },
  TContext
> => {
  const mutationKey = ['googleAuthUsersAuthGooglePost'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof googleAuthUsersAuthGooglePost>>,
    { data: GoogleAuthorizationToken }
  > = (props) => {
    const { data } = props ?? {};

    return googleAuthUsersAuthGooglePost(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type GoogleAuthUsersAuthGooglePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof googleAuthUsersAuthGooglePost>>
>;
export type GoogleAuthUsersAuthGooglePostMutationBody = GoogleAuthorizationToken;
export type GoogleAuthUsersAuthGooglePostMutationError = AxiosError<HTTPValidationError>;

/**
 * @summary Google Auth
 */
export const useGoogleAuthUsersAuthGooglePost = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof googleAuthUsersAuthGooglePost>>,
      TError,
      { data: GoogleAuthorizationToken },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof googleAuthUsersAuthGooglePost>>,
  TError,
  { data: GoogleAuthorizationToken },
  TContext
> => {
  const mutationOptions = getGoogleAuthUsersAuthGooglePostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get User Info
 */
export const getUserInfoUsersUserGet = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<UserInfo>> => {
  return axios.get(`/users/user`, options);
};

export const getGetUserInfoUsersUserGetQueryKey = () => {
  return [`/users/user`] as const;
};

export const getGetUserInfoUsersUserGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserInfoUsersUserGet>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getUserInfoUsersUserGet>>, TError, TData>
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserInfoUsersUserGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserInfoUsersUserGet>>> = ({
    signal,
  }) => getUserInfoUsersUserGet({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserInfoUsersUserGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetUserInfoUsersUserGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserInfoUsersUserGet>>
>;
export type GetUserInfoUsersUserGetQueryError = AxiosError<unknown>;

export function useGetUserInfoUsersUserGet<
  TData = Awaited<ReturnType<typeof getUserInfoUsersUserGet>>,
  TError = AxiosError<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserInfoUsersUserGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserInfoUsersUserGet>>,
          TError,
          Awaited<ReturnType<typeof getUserInfoUsersUserGet>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetUserInfoUsersUserGet<
  TData = Awaited<ReturnType<typeof getUserInfoUsersUserGet>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserInfoUsersUserGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserInfoUsersUserGet>>,
          TError,
          Awaited<ReturnType<typeof getUserInfoUsersUserGet>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetUserInfoUsersUserGet<
  TData = Awaited<ReturnType<typeof getUserInfoUsersUserGet>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserInfoUsersUserGet>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get User Info
 */

export function useGetUserInfoUsersUserGet<
  TData = Awaited<ReturnType<typeof getUserInfoUsersUserGet>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserInfoUsersUserGet>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetUserInfoUsersUserGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get Races
 */
export const getRacesF1SessionsGet = (
  params?: GetRacesF1SessionsGetParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Race[]>> => {
  return axios.get(`/f1/sessions`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getGetRacesF1SessionsGetQueryKey = (params?: GetRacesF1SessionsGetParams) => {
  return [`/f1/sessions`, ...(params ? [params] : [])] as const;
};

export const getGetRacesF1SessionsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getRacesF1SessionsGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params?: GetRacesF1SessionsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRacesF1SessionsGet>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRacesF1SessionsGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRacesF1SessionsGet>>> = ({ signal }) =>
    getRacesF1SessionsGet(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRacesF1SessionsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetRacesF1SessionsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRacesF1SessionsGet>>
>;
export type GetRacesF1SessionsGetQueryError = AxiosError<HTTPValidationError>;

export function useGetRacesF1SessionsGet<
  TData = Awaited<ReturnType<typeof getRacesF1SessionsGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params: undefined | GetRacesF1SessionsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRacesF1SessionsGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRacesF1SessionsGet>>,
          TError,
          Awaited<ReturnType<typeof getRacesF1SessionsGet>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRacesF1SessionsGet<
  TData = Awaited<ReturnType<typeof getRacesF1SessionsGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params?: GetRacesF1SessionsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRacesF1SessionsGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRacesF1SessionsGet>>,
          TError,
          Awaited<ReturnType<typeof getRacesF1SessionsGet>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetRacesF1SessionsGet<
  TData = Awaited<ReturnType<typeof getRacesF1SessionsGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params?: GetRacesF1SessionsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRacesF1SessionsGet>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get Races
 */

export function useGetRacesF1SessionsGet<
  TData = Awaited<ReturnType<typeof getRacesF1SessionsGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params?: GetRacesF1SessionsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRacesF1SessionsGet>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetRacesF1SessionsGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Session Drivers
 */
export const sessionDriversF1SessionDriversGet = (
  params: SessionDriversF1SessionDriversGetParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<RaceDriver[]>> => {
  return axios.get(`/f1/session_drivers`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getSessionDriversF1SessionDriversGetQueryKey = (
  params?: SessionDriversF1SessionDriversGetParams,
) => {
  return [`/f1/session_drivers`, ...(params ? [params] : [])] as const;
};

export const getSessionDriversF1SessionDriversGetQueryOptions = <
  TData = Awaited<ReturnType<typeof sessionDriversF1SessionDriversGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params: SessionDriversF1SessionDriversGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionDriversF1SessionDriversGet>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSessionDriversF1SessionDriversGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof sessionDriversF1SessionDriversGet>>> = ({
    signal,
  }) => sessionDriversF1SessionDriversGet(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof sessionDriversF1SessionDriversGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type SessionDriversF1SessionDriversGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof sessionDriversF1SessionDriversGet>>
>;
export type SessionDriversF1SessionDriversGetQueryError = AxiosError<HTTPValidationError>;

export function useSessionDriversF1SessionDriversGet<
  TData = Awaited<ReturnType<typeof sessionDriversF1SessionDriversGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params: SessionDriversF1SessionDriversGetParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionDriversF1SessionDriversGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionDriversF1SessionDriversGet>>,
          TError,
          Awaited<ReturnType<typeof sessionDriversF1SessionDriversGet>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useSessionDriversF1SessionDriversGet<
  TData = Awaited<ReturnType<typeof sessionDriversF1SessionDriversGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params: SessionDriversF1SessionDriversGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionDriversF1SessionDriversGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionDriversF1SessionDriversGet>>,
          TError,
          Awaited<ReturnType<typeof sessionDriversF1SessionDriversGet>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useSessionDriversF1SessionDriversGet<
  TData = Awaited<ReturnType<typeof sessionDriversF1SessionDriversGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params: SessionDriversF1SessionDriversGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionDriversF1SessionDriversGet>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Session Drivers
 */

export function useSessionDriversF1SessionDriversGet<
  TData = Awaited<ReturnType<typeof sessionDriversF1SessionDriversGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params: SessionDriversF1SessionDriversGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionDriversF1SessionDriversGet>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getSessionDriversF1SessionDriversGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary User Session Guess
 */
export const userSessionGuessF1GuessPost = (
  guess: Guess,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.post(`/f1/guess`, guess, options);
};

export const getUserSessionGuessF1GuessPostMutationOptions = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userSessionGuessF1GuessPost>>,
    TError,
    { data: Guess },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userSessionGuessF1GuessPost>>,
  TError,
  { data: Guess },
  TContext
> => {
  const mutationKey = ['userSessionGuessF1GuessPost'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userSessionGuessF1GuessPost>>,
    { data: Guess }
  > = (props) => {
    const { data } = props ?? {};

    return userSessionGuessF1GuessPost(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserSessionGuessF1GuessPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof userSessionGuessF1GuessPost>>
>;
export type UserSessionGuessF1GuessPostMutationBody = Guess;
export type UserSessionGuessF1GuessPostMutationError = AxiosError<HTTPValidationError>;

/**
 * @summary User Session Guess
 */
export const useUserSessionGuessF1GuessPost = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof userSessionGuessF1GuessPost>>,
      TError,
      { data: Guess },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof userSessionGuessF1GuessPost>>,
  TError,
  { data: Guess },
  TContext
> => {
  const mutationOptions = getUserSessionGuessF1GuessPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Session Standing
 */
export const sessionStandingF1SessionStandingPost = (
  params?: SessionStandingF1SessionStandingPostParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Standings>> => {
  return axios.post(`/f1/session_standing`, undefined, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getSessionStandingF1SessionStandingPostMutationOptions = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sessionStandingF1SessionStandingPost>>,
    TError,
    { params?: SessionStandingF1SessionStandingPostParams },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sessionStandingF1SessionStandingPost>>,
  TError,
  { params?: SessionStandingF1SessionStandingPostParams },
  TContext
> => {
  const mutationKey = ['sessionStandingF1SessionStandingPost'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sessionStandingF1SessionStandingPost>>,
    { params?: SessionStandingF1SessionStandingPostParams }
  > = (props) => {
    const { params } = props ?? {};

    return sessionStandingF1SessionStandingPost(params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SessionStandingF1SessionStandingPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof sessionStandingF1SessionStandingPost>>
>;

export type SessionStandingF1SessionStandingPostMutationError = AxiosError<HTTPValidationError>;

/**
 * @summary Session Standing
 */
export const useSessionStandingF1SessionStandingPost = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sessionStandingF1SessionStandingPost>>,
      TError,
      { params?: SessionStandingF1SessionStandingPostParams },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sessionStandingF1SessionStandingPost>>,
  TError,
  { params?: SessionStandingF1SessionStandingPostParams },
  TContext
> => {
  const mutationOptions = getSessionStandingF1SessionStandingPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get Winners
 */
export const getWinnersResultsWinnersGet = (
  params?: GetWinnersResultsWinnersGetParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<GetWinnersResultsWinnersGet200>> => {
  return axios.get(`/results/winners`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getGetWinnersResultsWinnersGetQueryKey = (
  params?: GetWinnersResultsWinnersGetParams,
) => {
  return [`/results/winners`, ...(params ? [params] : [])] as const;
};

export const getGetWinnersResultsWinnersGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getWinnersResultsWinnersGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params?: GetWinnersResultsWinnersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getWinnersResultsWinnersGet>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWinnersResultsWinnersGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWinnersResultsWinnersGet>>> = ({
    signal,
  }) => getWinnersResultsWinnersGet(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getWinnersResultsWinnersGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> };
};

export type GetWinnersResultsWinnersGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getWinnersResultsWinnersGet>>
>;
export type GetWinnersResultsWinnersGetQueryError = AxiosError<HTTPValidationError>;

export function useGetWinnersResultsWinnersGet<
  TData = Awaited<ReturnType<typeof getWinnersResultsWinnersGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params: undefined | GetWinnersResultsWinnersGetParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getWinnersResultsWinnersGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWinnersResultsWinnersGet>>,
          TError,
          Awaited<ReturnType<typeof getWinnersResultsWinnersGet>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetWinnersResultsWinnersGet<
  TData = Awaited<ReturnType<typeof getWinnersResultsWinnersGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params?: GetWinnersResultsWinnersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getWinnersResultsWinnersGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWinnersResultsWinnersGet>>,
          TError,
          Awaited<ReturnType<typeof getWinnersResultsWinnersGet>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
export function useGetWinnersResultsWinnersGet<
  TData = Awaited<ReturnType<typeof getWinnersResultsWinnersGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params?: GetWinnersResultsWinnersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getWinnersResultsWinnersGet>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };
/**
 * @summary Get Winners
 */

export function useGetWinnersResultsWinnersGet<
  TData = Awaited<ReturnType<typeof getWinnersResultsWinnersGet>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params?: GetWinnersResultsWinnersGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getWinnersResultsWinnersGet>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getGetWinnersResultsWinnersGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
